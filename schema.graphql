type EditObject {
  backgroundColor: String
  changed: Boolean
  deleted: Boolean
  floorId: String!
  height: Int
  id: String!
  updateAt: Float
  width: Int
  x: Int
  y: Int
  name: String
  personId: String
  fontSize: Int
  type: String
  url: String
}

type PatchObject {
  flag: String!
  object: EditObject!
  result: String
}

schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

type Query {
  listEditObjectsOnFloor(floorId: String!): [EditObject!]!
}

input EditObjectInput {
  backgroundColor: String
  changed: Boolean
  deleted: Boolean
  floorId: String!
  height: Int
  id: String!
  updateAt: Float
  width: Int
  x: Int
  y: Int
  name: String
  personId: String
  fontSize: Int
  type: String
  url: String
}

input PatchObjectInput {
  flag: String!
  object: EditObjectInput!
  result: String
}

type Mutation {
  patchObjects(
    objects: [PatchObjectInput!]!
  ): PatchObjectsOutput
}

type PatchObjectsOutput {
  objects: [PatchObject!]

  # This floors information enables the subscription to select only specific floor
  # The given objects are required to belong to the same floor
  updatedFloorId: String!
}

type Subscription {
  patchedObjects(updatedFloorId: String): PatchObjectsOutput
  @aws_subscribe(mutations: ["patchObjects"])
}
